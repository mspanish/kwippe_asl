<script>

import { coloringIndex, coloringMode, user, drawType, fillCol, outlineCol, onscreen, settings, currentPalette } from '../store.js';
import { onMount } from 'svelte';
import { fabric } from "fabric";

import { fetchText } from '../scripts/image.js';
import { jsonToFabric } from '../scripts/importer.js';
import { sample } from '../scripts/utilities.js';
import { hexToRgb } from '../scripts/colorConverters.js';
import { colorIsLight } from '../scripts/colorHelpers.js';

import ZIndex from '../components/tools/ZIndex.svelte';
import Coloring from '../components/tools/Coloring.svelte';
import TextTools from '../components/tools/Text.svelte';
import DrawingTools from '../components/tools/Drawing.svelte';
import Hamburger from '../components/Hamburger.svelte';
import EquationEditor from '../components/EquationEditor.svelte';

import Palettes from '../components/Palettes.svelte';

$drawType = 'text';
$onscreen.palettes = true;
$onscreen.palettesList = false;
$onscreen.showColors = true;
$onscreen.slideMenu = 'text';

let open = false;
let bgColor = '#E5E4E5';
$: { 
    if (['pen','select', 'text', 'math'].includes($drawType) ) {
        open = true;
    }
}

let mounted = false;

var mouseFrom = {x: 0, y: 0},
mouseTo = {x: 10, y: 10},
canvasObjectIndex = 0,
textbox = null,
origX, origY;

var line, isDown,mode;
mode = 'draw';

let canvas, opts;
var modifySize = 15, modifySmallSize = 10; 
var scale = 1.5;
var drawWidth = 0; 
var color = $fillCol || "#000000";
let outlineColor = $outlineCol || 'rgba(202, 0, 69, 0.95)';
//"rgba(161, 112, 112, 0.23)"; 
var drawingObject = null; 
var moveCount = 1; 
var doDrawing = false; 
var theActiveObject = false;

<<<<<<< HEAD
let tools = ['text', 'textbox', 'pen', 'select', 'right', 'wrong','arrow', 'math', 'line','dottedline','circle','ellipse','rectangle','rightangle','equilateral','clear']
=======
let tools = ['text', 'speechbubble', 'pen', 'select', 'right', 'wrong','arrow', 'math', 'line','dottedline','circle','ellipse','rectangle','rightangle','equilateral','clear']
>>>>>>> 7050c717456fbeac08a53a561ee3d3186140daa0

const importImage = () => {

    let input = document.getElementById('pdf_url')
    let url = input.value;
    console.log('url '+url)
    if (url) {
        let pointer = {x: 100, y:100};
        let origin = 'import'
        fetchText(url, pointer, origin, canvas, $settings, $fillCol, $outlineCol);
    }
}

onMount(() => {
	mounted = true;
	initFabric();
    //setMenu();
   // setPickrs();
    $onscreen.importImage = true;
});

const initFabric = () => {
 
    canvas = new fabric.Canvas("c", {
    isDrawingMode: false,
   // preserveObjectStacking:true,
    //perPixelTargetFind : true,
    //targetFindTolerance: 4,
    //skipTargetFind: true,
    // selectable: true,
    // selection: true
    });
    canvas.selectionColor = "rgba(0,0,0,0.05)"
    fabric.Object.prototype.transparentCorners = false;
    fabric.Object.prototype.originX = fabric.Object.prototype.originY = 'center';
    
//per https://stackoverflow.com/questions/56793737/fabricjs-canvas-memory-use-exceeds-the-maximum-limit-in-ipad
    fabric.Object.prototype.objectCaching = false;

    window.canvas = canvas;
    window.zoom = window.zoom ? window.zoom : 1;

    canvas.freeDrawingBrush.color = outlineColor; 
    canvas.freeDrawingBrush.width = drawWidth;
    
    jsonToFabric(canvas);

    canvas.on('mouse:down', function(o){
        isDown = true;
        var pointer = canvas.getPointer(o.e);
        var points = [ pointer.x, pointer.y, pointer.x, pointer.y ];
        mouseTo = {x: pointer.x, y:pointer.y}
        origX = pointer.x;
        origY = pointer.y;
        canvas.isDrawingMode = false;
    
    if (mode == "draw") {

        var canvasObject = null;      
        opts = {
            fill: color,
            stroke: outlineColor,
            originX: 'center',
            originY: 'center',
            hasBorders: false,
            selectable: true,
            selected: false,
            targetFindTolerance: true          
        }    
        let checkOpts = {
            stroke: 'red',
            strokeWidth: drawWidth,
            fill: 'transparent'        
        }
        if (['line','dottedline'].includes($drawType)) {
            opts.strokeWidth = 5
            canvasObject = new fabric.Line(points, opts);        
        }

        switch ($drawType) {
            case "pen":
                canvas.isDrawingMode = true;
                return
            break;   
            case "line2":
                canvasObject.strokeWidth = 5;
                /*
                this is how to do a pattern filled line, super cool 
                fabric.util.loadImage('http://fabricjs.com/assets/escheresque_ste.png', function (img) {
                
                    canvasObject.stroke = new fabric.Pattern({
                        source: img,
                        repeat: 'repeat'
                    });
                });                
                */
            break;
            case "dottedline":
                canvasObject.strokeWidth = 5;
                canvasObject.strokeDashArray = [10, 3];   
            break;
<<<<<<< HEAD
            case "textbox":
=======
            case "speechbubble":
>>>>>>> 7050c717456fbeac08a53a561ee3d3186140daa0
                  canvasObject = new fabric.Textbox("", {
                    left:  pointer.x,
                    top: pointer.y - 10,
                    fontSize: 40,
                    fontFamily: 'helvetica',
                    fill: $fillCol || '#000000',
                    fontWeight: '',
                    originX: 'left',
                    width: 300,
                    hasRotatingPoint: true,
                    centerTransform: true
                })

                canvas.add(canvasObject)
                canvas.setActiveObject(canvasObject);
                canvasObject.enterEditing();
                canvasObject.hiddenTextarea.focus();            
                return
            break;
            case "text":
                canvasObject = new fabric.IText("", {
                    left:  pointer.x,
                    top: pointer.y - 10,
                    width: 200,
                    fontSize: 30,
                    padding: 10,
                    originX: 'left',
                    textAlign: 'center',
                    borderColor: outlineColor,
                    fill: $fillCol || '#000000',
                })
                canvas.add(canvasObject)
                canvas.setActiveObject(canvasObject);
                canvasObject.enterEditing();
                canvasObject.hiddenTextarea.focus();  
                return
            break;
            case "arrow": 
                console.log('got arrow')
                opts.strokeWidth = 5;
                canvasObject = new fabric.LineArrow(points, opts);         
            break;    
            case "circle": 
                canvasObject = new fabric.Circle({
                    left: pointer.x,
                    top: pointer.y,
                    stroke: outlineColor,
                    fill: $fillCol || getRandomColor(),
                    originX: "center",
                    originY: "center",        
                    radius: 1,
                    strokeWidth: drawWidth,
                });                
            break;  
            case "rectangle":
                canvasObject = new fabric.Rect({
                    left: pointer.x,
                    top: pointer.y,
                    originX: 'left',
                    originY: 'top',
                    stroke: outlineColor,  
                    strokeWidth: drawWidth,                    
                    width: pointer.x - origX,
                    height: pointer.y - origY,
                    angle: 0,
                    rx: 10,
                    ry: 10,
                    fill: $fillCol || getRandomColor(),
                });
            break;
            case 'equilateral':
                let height = pointer.y - origY;
                canvasObject = new fabric.Triangle({
                top: pointer.y,
                left: pointer.x,
                width: Math.sqrt(Math.pow(height, 2) + Math.pow(height / 2.0, 2)),
                height: height,
                stroke: outlineColor,
                strokeWidth: drawWidth,
                fill: $fillCol || getRandomColor(),
            });            
            break;
            case 'rightangle':
                opts = {
                    stroke: outlineColor,
                    strokeWidth: drawWidth,
                    fill: $fillCol || getRandomColor(),
                    left: origX,
                    top: origY,
                    width: pointer.x - origX,
                    height: pointer.y - origY,
                }
                canvasObject = new fabric.RectangleTriangle(opts);
            break;
            case 'ellipse':
                canvasObject = new fabric.Ellipse({
                    left: pointer.x,
                    top: pointer.y,
                    stroke: outlineColor,
                    strokeWidth: drawWidth,
                    fill: $fillCol || getRandomColor(),
                    originX: 'center', 
                    originY: 'center',
                    rx: 5,
                    ry: 1
                });            
            break;
            case 'right': 
                console.log('right draw')
                let y = origY + 10; 
                var path =
                "M " +
                (origX - modifySize) +
                " " +
                (y - modifySize) +
                " L " +
                origX +
                " " +
                y +
                " L " +
                (origX + modifySize * 2) +
                " " +
                (y - modifySize * 2);
                checkOpts.stroke = 'green'
                canvasObject = new fabric.Path(path,checkOpts);
            break; 
            case 'wrong':
                var path =
                "M " +
                (origX - modifySize) +
                " " +
                (origY - modifySize) +
                " L " +
                (origX + modifySize) +
                " " +
                (origY + modifySize) +
                "M " +
                (origX + modifySize) +
                " " +
                (origY - modifySize) +
                " L " +
                (origX - modifySize) +
                " " +
                (origY + modifySize);
                canvasObject = new fabric.Path(path,checkOpts);            
            break;
            } // end switch
<<<<<<< HEAD
            if (!['text', 'textbox'].includes($drawType) && canvasObject) canvas.add(canvasObject);
=======
            if (!['text', 'speechbubble'].includes($drawType) && canvasObject) canvas.add(canvasObject);
>>>>>>> 7050c717456fbeac08a53a561ee3d3186140daa0

            drawingObject = canvasObject;
            
        } // end if mode is draw and not select
    });
    
    canvas.on('mouse:move', function(o){
    /*
    if ($drawType == 'text' && isDown) {
        console.log('mouseMOVE on TEXT')
        $drawType = 'select';
        //drawingObject.exitEditing();
        //drawingObject.set({'selected': true});
        let selectBtn = document.getElementById('selectBtn')
        resetTools(selectBtn)
    }
      */   
    
    if (!isDown) return;
    let pointer = canvas.getPointer(o.e);
    mouseTo = {x: pointer.x, y:pointer.y}
    var left = pointer.x, top = pointer.y;

<<<<<<< HEAD
    if ($drawType == "textbox" || $drawType == 'text') return
=======
    if ($drawType == "speechbubble" || $drawType == 'text') return
>>>>>>> 7050c717456fbeac08a53a561ee3d3186140daa0
    
    if (mode == "draw") {
        if (['line', 'arrow', 'dottedline'].includes($drawType)){
            drawingObject.set({ x2: pointer.x, y2: pointer.y });
            drawingObject.setCoords();       
        }
        switch($drawType) {
            case "circle":
                drawingObject.set({
                    radius: Math.abs(origX - pointer.x)
                });
            break;

            case "rectangle":
                if (origX > pointer.x) {
                    drawingObject.set({left: Math.abs(pointer.x)});
                }
                if (origY > pointer.y) {
                    drawingObject.set({top: Math.abs(pointer.y)});
                }
                drawingObject.set({width: Math.abs(origX - pointer.x)});
                drawingObject.set({height: Math.abs(origY - pointer.y)});          
            break;
            case 'equilateral':
                drawingObject.set({ 
                    width: Math.abs(pointer.x - origX),
                    height: Math.abs(pointer.y - origY)
                });
            break;
            case 'rightangle':
                if (origX > pointer.x) {
                    drawingObject.set({left: Math.abs(pointer.x)});
                }
                if (origY > pointer.y) {
                    drawingObject.set({top: Math.abs(pointer.y)});
                }
                drawingObject.set({width: Math.abs(origX - pointer.x)});
                drawingObject.set({height: Math.abs(origY - pointer.y)});       
            break;
            case 'ellipse':
                drawingObject.set({ rx: Math.abs(origX - pointer.x),ry:Math.abs(origY - pointer.y) });            
            break;
        
        } // end switch
<<<<<<< HEAD
        
=======
        drawingObject.set({
            opacity: .7
        });
>>>>>>> 7050c717456fbeac08a53a561ee3d3186140daa0
        canvas.renderAll();
    } // end if draw mode and not select
    });

    canvas.on('mouse:up', function(o){
        isDown = false;
       // canvas.isDrawingMode = false;
        //canvas.freeDrawingBrush.onMouseUp();
<<<<<<< HEAD

=======
        drawingObject.set({
            opacity: 1
        });
>>>>>>> 7050c717456fbeac08a53a561ee3d3186140daa0
    });
    
    canvas.on('selection:created', function (o) {
        processSelection(o,'created')       
    });
    
    canvas.on('selection:updated', function (o) {
        processSelection(o,'updated')       
    });
    
    canvas.on('selection:cleared', function () {
       // mode = 'draw'
        console.log('there is a selection cleared >>')
        $onscreen.breakGroup = false;
        $onscreen.makeGroup = false;
    });
    
    const processSelection = (o,type) => {
    
        console.log(o)

        open = true;
        mode = 'select'
        $drawType = 'select';
        let selectBtn = document.getElementById('selectBtn')
        resetTools(selectBtn)
        
        console.log('there is a selection '+type)
        let items = canvas.getActiveObjects();
        
        console.log('lenny of selected items is '+items.length);
        
        for (let i = 0; i < items.length; i++) {
            if (items[i].type == 'group'){
                console.log('we have a group at '+i);
                $onscreen.breakGroup = true;
            }
        }
        if (items.length > 1) {
            console.log('selected items are GREATER than 1')
            $onscreen.makeGroup = true;
            $onscreen.slideMenu = 'zindex' 

           // $onscreen.showColors = false;
                   console.log('selection, slideMenu is now '+$onscreen.slideMenu)
        }
        else {
            $onscreen.showColors = true;
            $onscreen.slideMenu = 'text'
                    console.log('selection, slideMenu is now '+$onscreen.slideMenu)
            let type = o.selected.type;
            switch(type) {
                case 'text':
                    
                break;
                case 'svg':
                
                break;
                case 'shape':
                
                break;
            }
        }

    }

    var deleteIcon = "data:image/svg+xml,%3C%3Fxml version='1.0' encoding='utf-8'%3F%3E%3C!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3E%3Csvg version='1.1' id='Ebene_1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' width='595.275px' height='595.275px' viewBox='200 215 230 470' xml:space='preserve'%3E%3Ccircle style='fill:%23F44336;' cx='299.76' cy='439.067' r='218.516'/%3E%3Cg%3E%3Crect x='267.162' y='307.978' transform='matrix(0.7071 -0.7071 0.7071 0.7071 -222.6202 340.6915)' style='fill:white;' width='65.545' height='262.18'/%3E%3Crect x='266.988' y='308.153' transform='matrix(0.7071 0.7071 -0.7071 0.7071 398.3889 -83.3116)' style='fill:white;' width='65.544' height='262.179'/%3E%3C/g%3E%3C/svg%3E";

    var img = document.createElement('img');
    img.src = deleteIcon;
    
    function renderIcon(ctx, left, top, styleOverride, fabricObject) {
        var size = this.cornerSize;
        ctx.save();
        ctx.translate(left, top);
        ctx.rotate(fabric.util.degreesToRadians(fabricObject.angle));
        ctx.drawImage(img, -size/2, -size/2, size, size);
        ctx.restore();
    }
    
    fabric.Object.prototype.transparentCorners = false;
    fabric.Object.prototype.cornerColor = 'blue';
    fabric.Object.prototype.cornerStyle = 'circle';

    
    fabric.Object.prototype.controls.deleteControl = new fabric.Control({
        x: 0.5,
        y: -0.5,
        offsetY: 16,
        cursorStyle: 'pointer',
        mouseUpHandler: deleteObject,
        onMousedown: deleteObject,
        render: renderIcon,
        cornerSize: 24
    });

    // Extended fabric line class
    fabric.LineArrow = fabric.util.createClass(fabric.Line, {

        type: 'lineArrow',

        initialize: function(element, options) {
            options || (options = {});
            this.callSuper('initialize', element, options);
        },

        toObject: function() {
            return fabric.util.object.extend(this.callSuper('toObject'));
        },

        _render: function(ctx) {
            this.callSuper('_render', ctx);

            // do not render if width/height are zeros or object is not visible
            if (this.width === 0 || this.height === 0 || !this.visible) return;

            ctx.save();

            var xDiff = this.x2 - this.x1;
            var yDiff = this.y2 - this.y1;
            var angle = Math.atan2(yDiff, xDiff);
            ctx.translate((this.x2 - this.x1) / 2, (this.y2 - this.y1) / 2);
            ctx.rotate(angle);
            ctx.beginPath();
            //move 10px in front of line to start the arrow so it does not have the square line end showing in front (0,0)
            ctx.moveTo(10, 0);
            ctx.lineTo(-20, 15);
            ctx.lineTo(-20, -15);
            ctx.closePath();
            ctx.fillStyle = this.stroke;
            ctx.fill();
            ctx.restore();
        }
    });

    fabric.LineArrow.fromObject = function(object, callback) {
    callback && callback(new fabric.LineArrow([object.x1, object.y1, object.x2, object.y2], object));
    };
    fabric.LineArrow.async = true;
    
    fabric.RectangleTriangle = fabric.util.createClass(fabric.Rect, {
    type: 'rectangleTriangle',
    _render: function(ctx) {
        var w = this.width,
        h = this.height,
        x = -this.width / 2,
        y = -this.height / 2;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x, y + h);
        ctx.lineTo(x + w, y + h);
        ctx.lineTo(x, y);
        ctx.closePath();
        this._renderPaintInOrder(ctx);
    }
    });
    fabric.RectangleTriangle.fromObject = function(object, callback) {
        return fabric.Object._fromObject('RectangleTriangle', object, callback);
    };

    setTimeout(function(){
        //console.log('running setTimeout')
        var container = document.getElementsByClassName('canvas-container')[0]
        container.style.position = 'unset';
    },300)  

    document.onkeydown = e => {
        let key = window.event.keyCode;
        if (e.keyCode == 46) {
            deleteObj();
        }
        if (e.keyCode == 90 && e.ctrlKey) {
            canvas.remove(
                canvas.getObjects()[canvas.getObjects().length - 1]
            );
        }
    };   
    
    fabric.LabeledRect = fabric.util.createClass(fabric.Rect, {
    //var LabeledRect = fabric.util.createClass(fabric.Rect, {

    type: 'labeledRect',
    // initialize can be of type function(options) or function(property, options), like for text.
    // no other signatures allowed.
    initialize: function(options) {
        options || (options = { });

        this.callSuper('initialize', options);
        this.set('label', options.label || '');
    },

    toObject: function() {
        return fabric.util.object.extend(this.callSuper('toObject'), {
        label: this.get('label')
        });
    },

    _render: function(ctx) {
        this.callSuper('_render', ctx);
        let str = `${this.fontSize}px ${this.fontFamily}`;
        ctx.font = this.labelFont;
        ctx.fillStyle = this.labelFill;
        ctx.fillText(this.label, -this.width/2, -this.height/2 + 20);
    }
    });    


    fabric.Text.prototype.set({
    _getNonTransformedDimensions() { // Object dimensions
    return new fabric.Point(this.width, this.height).scalarAdd(this.padding);
    },

        _calculateCurrentDimensions() { // Controls dimensions
        return fabric.util.transformPoint(this._getTransformedDimensions(), this.getViewportTransform(), true);
        }
    });



    // Extended fabric object class
    fabric.SpeechBubble = fabric.util.createClass(fabric.Object, {

        type: 'speechBubble',

        initialize: function(element, options) {
            options || (options = {});
            this.callSuper('initialize', element, options);
        },

        toObject: function() {
            return fabric.util.object.extend(this.callSuper('toObject'));
        },

        _render: function(ctx) {
            this.callSuper('_render', ctx);

            // do not render if width/height are zeros or object is not visible
            //  if (this.width === 0 || this.height === 0 || !this.visible) return;
        }
    });

    fabric.SpeechBubble.fromObject = function(object, callback) {
        callback && callback(new fabric.SpeechBubble([object.x, object.y], object));
    };
    //fabric.SpeechBubble.async = true;

    fabric.RectangleTriangle = fabric.util.createClass(fabric.Rect, {
    type: 'rectangleTriangle',
    _render: function(ctx) {
        var w = this.width,
        h = this.height,
        x = -this.width / 2,
        y = -this.height / 2;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x, y + h);
        ctx.lineTo(x + w, y + h);
        ctx.lineTo(x, y);
        ctx.closePath();
        this._renderPaintInOrder(ctx);
    }
    });
    fabric.RectangleTriangle.fromObject = function(object, callback) {
        return fabric.Object._fromObject('RectangleTriangle', object, callback);
    };



//fabric.Object.prototype.uid = ... ;

} //end of initFabric


function selectNow() {
    mode = "select";   
    canvas.selection=true;
    canvas.perPixelTargetFind = true;
    canvas.targetFindTolerance = 4;
    canvas.renderAll();
};

// select all objects
function deleteObjects(){
    if (confirm('Delete everything, are you sure?')) {
       canvas.clear();
       $drawType = 'text';
       let txtBtn = document.getElementById('textBtn')
       resetTools(txtBtn)
    }
}

function transformMouse(mouseX, mouseY) {
    return { x: mouseX / window.zoom, y: mouseY / window.zoom };
}
 
const setMenu = () => {
    let pdfBtn = document.getElementById('pdf_import_btn');
    pdfBtn.addEventListener('click', function(e){ 
        console.log('pdf import')
        input = document.getElementById('pdf_url')
        url = input.value;
        console.log('url '+url)
        if (url) {
            //loadPDF(url);
            loadImage(url);
        }
    })
    let saveBtn = document.getElementById('save_pdf');
    saveBtn.addEventListener('click', function(e){ 
        console.log('pdf save')
        //savePDF()
    })      
}

function toolClick(event) {
    let el = event.target;
    let dt = el.getAttribute('data-type')
    console.log('tool click '+dt)
    
    if (dt == 'text') $onscreen.slideMenu = 'text';
    if (dt == 'select') $onscreen.slideMenu = 'zindex';            
    
    if (el.id == 'clearBtn') {
        deleteObjects()
    }
    $drawType = el.getAttribute('data-type')
    resetTools(el);

    
    if ($drawType == 'select') {
        mode = 'select'
    }
    else {
        mode = 'draw'
    }
}

function resetTools(el) {
    el.classList.add('active')
        //console.log('$drawType is '+$drawType)
    let idiv = el.querySelector('i')        
        idiv.className = '';
        idiv.classList.add('icon-tools')
        idiv.classList.add('icon-'+$drawType+'-select')
    
    let sibs = getSiblings(el)
    for (let sib of sibs) {
        sib.classList.remove('active')
        let dType = sib.getAttribute('data-type')
        let idiv = sib.querySelector('i')
        idiv.className = '';
        idiv.classList.add('icon-tools')
        idiv.classList.add('icon-'+dType+'-black')                
    }         
}

var getSiblings = function (elem) {
    var siblings = [];
    var sibling = elem.parentNode.firstChild;
    while (sibling) {
        if (sibling.nodeType === 1 && sibling !== elem) {
            siblings.push(sibling);
        }
        sibling = sibling.nextSibling
    }
    return siblings;
}; 

function deleteObject(eventData, target) {
    console.log('trying to delete '+target)
    var canvas = target.canvas; 
    canvas.remove(target);
    canvas.requestRenderAll();
}
 
function deleteObj() {
    canvas.getActiveObjects().map(item => {
        canvas.remove(item);
    });
};


 
//TODO: add a uniform stroke to selected objects button someplace in order to use this

fabric.Object.prototype.noScaleCache = false;
/*
	strokeUniform works better without scalingCache
	Objects in group are not scaled directly, so stroke uniform will not have effect.
*/
function toggleUniform() {
	var aObject = canvas.getActiveObject();
	if (aObject.type === 'activeSelection') {
		aObject.getObjects().forEach(function(obj) {
			obj.set('strokeUniform', !obj.strokeUniform);
		});
	} else {
		aObject.set('strokeUniform', !aObject.strokeUniform);
	}
	canvas.requestRenderAll();
}
 
 
let loadPDF = (url) => {
    let inst = {}
// need to verify url here
    console.log('loadPDF val '+url);
    
    if (!url) return
    
    console.log('trying to load pdf from url '+url);
    var loadingTask = PDFJS.getDocument(url);
    
    loadingTask.promise.then(function (pdf) {

    inst.pages_rendered = 0
    inst.number_of_pages = pdf.pdfInfo.numPages;
    console.log('how many pages? '+inst.number_of_pages)
    
    for (var i = 1; i <= pdf.pdfInfo.numPages; i++) {
        pdf.getPage(i).then(function (page) {
            console.log('getting pdf page '+i)
            var viewport = page.getViewport(scale);
            //console.log('viewport is '+JSON.stringify(viewport))
            var canvas = document.createElement('canvas');
            document.getElementById('canvasDiv').parentNode.prepend(canvas);

            canvas.className = 'pdf-canvas';
            canvas.height = viewport.height;
            canvas.width = viewport.width;
  
            context = canvas.getContext('2d');
            
            let c = document.getElementById('c');
            let uc = document.getElementsByClassName('upper-canvas')[0];                
            c.style.height = viewport.height;
            uc.style.height = viewport.height;                

            var renderContext = {
                canvasContext: context,
                viewport: viewport
            };
            var renderTask = page.render(renderContext);
            renderTask.then(function () {
                pdf_pages = document.getElementsByClassName('pdf-canvas');
                
                for (let i = 0; i < pdf_pages.length; i++) {
                //  $('.pdf-canvas').each(function (index, el) {
                    let idy = 'page-' + (i + 1) + '-canvas';
                    pdf_pages[i]['id'] = idy
                //});
                }
                inst.pages_rendered++;
                console.log('pages rendered = ')
                console.log(inst.pages_rendered)
                if (inst.pages_rendered == inst.number_of_pages) {
                    console.log('rendered your pdf!')
                }
            });
        });
      }
    })
} // end loadPDF()
 
function savePDF(){
    var imgData = canvas.toDataURL("image/jpeg", 1.0);
    var pdf = new jsPDF();

    pdf.addImage(imgData, 'JPEG', 0, 0);
    pdf.save("download.pdf");
}

// src="js/cheetahGrid.js"  on:load={mathjaxLoaded}

const makeGroup = () => {
    if (!canvas.getActiveObject()) {
          return;
    }
    if (canvas.getActiveObject().type !== 'activeSelection') {
        return;
    }
    canvas.getActiveObject().toGroup();
    canvas.requestRenderAll();
}

const breakGroup = () => {
      if (!canvas.getActiveObject()) {
          return;
        }
        if (canvas.getActiveObject().type !== 'group') {
          return;
        }
        canvas.getActiveObject().toActiveSelection();
        canvas.requestRenderAll();
}

function pad(str, length) {
    while (str.length < length) {
        str = '0' + str;
    }
    return str;
}

var getRandomInt = fabric.util.getRandomInt;

function getRandomColor() {
    let mode = $coloringMode || 'stepped';
    console.log('type is '+mode)

    let reversePalette = [];
    for (let c of $currentPalette) {
        reversePalette.push(c)
    }
    reversePalette = reversePalette.reverse();
    
    let lenny = $currentPalette.length - 1;
        
    if ($coloringIndex > lenny) {
        $coloringIndex = 0;
    }
    console.log('$coloringIndex is '+$coloringIndex)
    console.log('lenny is '+lenny)
    switch (mode) {
        case 'single':
            color = $fillCol || $currentPalette[0]
        break;
        
        case 'stepped':
            color = $currentPalette[$coloringIndex]
        break;

        case 'stepped_reverse':
            color = reversePalette[$coloringIndex]
        break;

        case 'random':
            color = sample($currentPalette)
        break;
    }   
    $coloringIndex++;
    return color;
    
    //(
//         pad(getRandomInt(0, 255).toString(16), 2) +
//         pad(getRandomInt(0, 255).toString(16), 2) +
//         pad(getRandomInt(0, 255).toString(16), 2)
    //);
}
let paletteButton = 'choose palette';

const objectQuickColor = (e) => {
    let color = e.target.id;

    canvas.getActiveObjects().map(item => {
        console.log('changing color, type is ' +item.type)
        
        item.set('fill', color)
        if (item.type == 'group') {
            console.log(item)
                if (item._objects) {
                    item._objects.map(subitem => {
                        subitem.set('fill', color)
                    })
                }
        }
        
        if (['lineArrow', 'line', 'dottedline'].includes(item.type) ) {
            item.set('stroke', color)
        }
        if (['i-text'].includes(item.type)) {
            console.log(item)
            if (item.textBackgroundColor) {
                let rgb = hexToRgb(color.toString());
                let textContrast = colorIsLight(rgb) ? '#000000' : '#ffffff';
                item.set({'textBackgroundColor':color, 'fill': textContrast})
            }
            else {
                item.set({'fill': color})
            }
        }
    });  
    canvas.renderAll();
}

</script>

<style> 

:global(#content) {
    margin-top: 70px !important;
}

#menu {
    padding-left: 60px;
}
#wrapper {
    margin-top: -60px;
}
:global(.colorbox) {
    display: inline-block;
    border-radius: 90px;
    width: 40px;
    height: 40px;
    margin: 10px;
    margin-top: 5px;
}
:global(#paletteChooser) {
    display: inline-block;
}
</style>
<svelte:head>
    <link rel="stylesheet" href="editor.css">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/1.3.3/jspdf.min.js"></script>
    <!-- on:load={fabricLoaded} src="js/fabric.min.js" -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/1.8.349/pdf.min.js"></script>
</svelte:head>

<div style="position: absolute; width: 100%; height:100%; background-color:{bgColor}">

    <div id="menu">
        {#if !$onscreen.showColors}
        
            <div id="pdf_import">
                <input id="pdf_url" type="text" placeholder="paste url here" />
                <button id="pdf_import_btn">open pdf</button>
            </div>
            <div id="save">
                <button on:click="{savePDF}" id="save_pdf">save</button>
            </div>
            {#if $onscreen.importImage}
                <div id="importImage">
                    <button on:click="{importImage}">import image</button>
                </div>        
            {/if}   

        {/if}
        
        {#if $onscreen.palettes}    
            <div id="paletteChooser">
                <Palettes {paletteButton}></Palettes>
            </div>
        {/if}
        
        {#if $onscreen.showColors && $currentPalette && $currentPalette.length > 0}
            {#each $currentPalette as color} 
                <div id={color} class="colorbox" on:click={objectQuickColor} style="background-color:{color}"></div>
            {/each}
        {/if}
    </div>
<<<<<<< HEAD

    <Hamburger bind:open={open} {$drawType}/>

=======
    {#if open }
        <Hamburger bind:open={open} {$drawType}/>
    {/if}
>>>>>>> 7050c717456fbeac08a53a561ee3d3186140daa0
    <aside class="slideIn { open ? 'open' : ''}" >
    
        {#if $onscreen.slideMenu == 'zindex'}
            <ZIndex bind:canvas={canvas} ></ZIndex>

            <Coloring bind:canvas={canvas} ></Coloring>

            {#if $onscreen.breakGroup}
                <div id="breakGroup">
                    <button on:click="{breakGroup}">ungroup</button>
                </div>        
            {/if}
            {#if $onscreen.makeGroup}
                <div id="makeGroup">
                    <button on:click="{makeGroup}">group</button>
                </div>        
            {/if}             
   
        {/if}
        
    
        {#if $onscreen.slideMenu == 'math'}
            <EquationEditor bind:canvas={canvas} ></EquationEditor>
        {/if}

        {#if $onscreen.slideMenu == 'text'}
  
            <TextTools bind:canvas={canvas} ></TextTools>
        {/if}
        {#if $onscreen.slideMenu == 'pen'}
            <DrawingTools bind:canvas={canvas} ></DrawingTools>
        {/if}

    </aside>

    <div id="wrapper">
        <div id="toolbar">                  
            <ul id="toolsul" class="tools">
                {#each tools as tool}
                    <li id="{tool}Btn" on:click={toolClick} data-type="{tool}" class="{tool == 'text' ? 'active' : ''}">
                        <i class="icon-tools icon-{tool}-{tool == 'text' ? 'select' : 'black'}"></i>
                    </li>
                {/each}
            </ul>
        </div>
        <div id="canvasWrapper">
            <div id="canvasDiv" class="canvasDiv" style="width:95%;">
                <canvas bind:this={canvas} id="c" width="1920" height="1080"></canvas>
            </div>
        </div>
    </div>


</div>
